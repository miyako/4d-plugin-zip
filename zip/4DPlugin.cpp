/* --------------------------------------------------------------------------------
 #
 #	4DPlugin.cpp
 #	source generated by 4D Plugin Wizard
 #	Project : Zip
 #	author : miyako
 #	2016/03/08
 #
 # --------------------------------------------------------------------------------*/


#include "4DPluginAPI.h"
#include "4DPlugin.h"

#define YIELD_FACTOR 0x0100

void PluginMain(PA_long32 selector, PA_PluginParameters params)
{
	try
	{
		PA_long32 pProcNum = selector;
		sLONG_PTR *pResult = (sLONG_PTR *)params->fResult;
		PackagePtr pParams = (PackagePtr)params->fParameters;

		CommandDispatcher(pProcNum, pResult, pParams); 
	}
	catch(...)
	{

	}
}

void CommandDispatcher (PA_long32 pProcNum, sLONG_PTR *pResult, PackagePtr pParams)
{
	switch(pProcNum)
	{
// --- Zip

		case 1 :
			Unzip(pResult, pParams);
			break;

		case 2 :
			Zip(pResult, pParams);
			break;

	}
}

#pragma mark -

#if VERSIONMAC
void convertPathToCodepage(std::string &path, UInt32 codepage)
{
    CFStringEncoding encoding = _CFStringConvertWindowsCodepageToEncoding(codepage);
    if((encoding != kCFStringEncodingInvalidId) && CFStringIsEncodingAvailable(encoding))
    {
        NSString *str = (NSString *)CFStringCreateWithBytes(kCFAllocatorDefault,
                                                            (const UInt8 *)path.c_str(),
                                                            path.length(),
                                                            kCFStringEncodingUTF8,
                                                            true);
        if(str)
        {
            uint32_t size = CFStringGetMaximumSizeForEncoding([str length], encoding) + sizeof(PA_Unichar);    //2 bytes for null termination
            std::vector<uint8_t> buf(size);
            CFIndex len = 0;
            CFStringGetBytes((CFStringRef)str, CFRangeMake(0, [str length]), encoding, '?', false, (UInt8 *)&buf[0], size, &len);
            path = relative_path_t((char *)&buf[0], len);
            [str release];
        }
    }
}
#else
void convertPathToCodepage(std::string &path, DWORD codepage, IMultiLanguage2 *mlang)
{
    if(mlang)
    {
        C_TEXT tempUstr;
        UINT len, mlen, ulen;
        DWORD mode = 0;
        tempUstr.setUTF8String((const uint8_t *)path.c_str(), path.length());
        ulen = -1;
        LPWSTR ustr = (LPWSTR)tempUstr.getUTF16StringPtr();
        mlang->ConvertStringFromUnicode(&mode, codepage, ustr, &ulen, NULL, &mlen);
        len = mlen+2;
        std::vector<uint8_t> buf(len);
        if(S_OK == mlang->ConvertStringFromUnicode(&mode, codepage, ustr, &ulen, (CHAR *)&buf[0], &mlen))
        {
            path = std::string((char *)&buf[0]);
        }
    }
}
#endif

#if VERSIONMAC
void convertPathFromCodepage(std::string &path, UInt32 codepage)
{
    CFStringEncoding encoding = _CFStringConvertWindowsCodepageToEncoding(codepage);
    if((encoding != kCFStringEncodingInvalidId) && CFStringIsEncodingAvailable(encoding))
    {
        NSString *str = (NSString *)CFStringCreateWithBytes(kCFAllocatorDefault,
                                                            (const UInt8 *)path.c_str(),
                                                            path.length(),
                                                            encoding,
                                                            true);
        if(str)
        {
            uint32_t size = CFStringGetMaximumSizeForEncoding([str length], kCFStringEncodingUTF8) + sizeof(PA_Unichar);    //2 bytes for null termination
            std::vector<uint8_t> buf(size);
            CFIndex len = 0;
            CFStringGetBytes((CFStringRef)str, CFRangeMake(0, [str length]), kCFStringEncodingUTF8, '?', false, (UInt8 *)&buf[0], size, &len);
            path = std::string((char *)&buf[0], len);
            [str release];
        }
    }
}
#else
void convertPathFromCodepage(std::string &path, DWORD codepage, IMultiLanguage2 *mlang)
{
    if(mlang)
    {
        LPSTR mstr = (LPSTR)path.c_str();
        UINT mlen = -1;
        UINT ulen, len;
        DWORD mode = 0;
        mlang->ConvertStringToUnicode(&mode, codepage, mstr, &mlen, NULL, &ulen);
        len = ((ulen * 2) + 2);
        std::vector<uint8_t> buf(len);
        if(S_OK == mlang->ConvertStringToUnicode(&mode, codepage, mstr, &mlen, (WCHAR *)&buf[0], &ulen))
        {
            C_TEXT tempUstr;
            tempUstr.setUTF16String((const PA_Unichar *)&buf[0], ulen);
            CUTF8String tempStr;
            tempUstr.copyUTF8String(&tempStr);
            path = std::string((char *)tempStr.c_str());
        }
    }
}
#endif

#pragma mark -

// -------------------------------------- Zip -------------------------------------

void Unzip(sLONG_PTR *pResult, PackagePtr pParams)
{
    C_TEXT Param1;
    C_TEXT Param2;
    C_TEXT Param3;
    C_LONGINT Param4;
    C_TEXT Param5;
    C_LONGINT Param6;
    C_LONGINT returnValue;
    
    Param1.fromParamAtIndex(pParams, 1);//src
    Param2.fromParamAtIndex(pParams, 2);//dst
    Param3.fromParamAtIndex(pParams, 3);//pass
    Param4.fromParamAtIndex(pParams, 4);//options
    Param5.fromParamAtIndex(pParams, 5);//callback
    Param6.fromParamAtIndex(pParams, 6);//codepage
    
    //pass
    std::string password;
    convertToString(Param3, password);
    bool with_password = (password.length() != 0);
    const char *pass = with_password ? password.c_str() : NULL;
    
    //src, dst
	CUTF8String input_path;
	Param1.copyPath(&input_path);
	const char *input = (const char*)input_path.c_str();
#if VERSIONMAC
    CUTF8String output_path;
    Param2.copyPath(&output_path);
    const char *output = (const char*)output_path.c_str();
#else
    const wchar_t *output = (const wchar_t*)Param2.getUTF16StringPtr();
#endif
    
    unsigned int flags = Param4.getIntValue();
    
    bool ignore_dot = !!(flags & 1L);
    
#if VERSIONMAC
    bool with_atttributes = !!(flags & 2L);
#else
    bool with_atttributes = false;
#endif
    
#if VERSIONWIN
    IMultiLanguage2 *mlang = NULL;
    CoCreateInstance(CLSID_CMultiLanguage, NULL, CLSCTX_INPROC_SERVER, IID_IMultiLanguage2, (void **)&mlang);
    DWORD codepage = 0;
#endif
    
    //callback
    method_id_t methodId = PA_GetMethodID((PA_Unichar *)Param5.getUTF16StringPtr());
    bool abortedByCallbackMethod = false;
    bool use_callback = Param5.getUTF16Length();
    
    int charset = Param6.getIntValue();
    
    double number_entry = 0;
    double num_of_file = 0;
    
    void *reader = NULL;
    
    mz_zip_reader_create(&reader);
    mz_zip_reader *h = (mz_zip_reader *)reader;
    
    unsigned int yield_counter = 0;
    
    std::vector<uint8_t> buf(BUFFER_SIZE);
    
    if(with_password)
    {
        mz_zip_writer_set_password(reader, pass);
    }
    
    int32_t err = mz_zip_reader_open_file(reader, input);
    
    if (err == MZ_OK)
    {
#if VERSIONMAC
        NSFileManager *fm = [[NSFileManager alloc]init];
        
        std::vector<TextEncoding> _encodings;
        TextEncoding *encodings = NULL;
        TECSnifferObjectRef sniffer = NULL;
        int len = MAX_LENGTH_FOR_ENCODING_NAME;
        ItemCount charset_count, charset_num;
        ItemCount numTextEncodings;
        ItemCount maxErrs;
        ItemCount maxFeatures;
        ItemCount *numErrsArray;
        if(charset == CHARSET_AUTOMATIC)
        {
            if(!TECCountAvailableTextEncodings(&charset_count))
            {
                _encodings.resize(charset_count);
                encodings = &_encodings[0];
                TECGetAvailableTextEncodings(encodings, charset_count, &charset_num);
                TECCreateSniffer(&sniffer, encodings, charset_num);
            }
        }
#else
        ULONG numTextEncodings = 0;
        if(mlang)
        {
            ULONG charset_count, charset_celt = 32;//    number of codes page information to retrive at a time
            MIMECPINFO charset_infos[32];
            IEnumCodePage* codepages = NULL;
            mlang->EnumCodePages(MIMECONTF_VALID, 0, &codepages);
            if(codepages)
            {
                while(codepages->Next(charset_celt, charset_infos, &charset_count) == S_OK)
                {
                    numTextEncodings += charset_count;
                }
                codepages->Release();
            }
        }
#endif
        mz_zip_file *zi = NULL;
        
        err = mz_zip_reader_goto_first_entry(reader);
        
        if (err == MZ_OK)
        {
            number_entry++;
            
            do
            {
                err = mz_zip_reader_entry_get_info(reader, &zi);
                
                 if (err == MZ_OK)
                 {
                     
                     err = mz_zip_reader_goto_next_entry(reader);
                     if (err == MZ_OK)
                     {
                         number_entry++;
                     }
                 }
                
            }
            while (err == MZ_OK);
            
            if (err == MZ_END_OF_LIST)
            {
                err = mz_zip_reader_goto_first_entry(reader);
                
                if (err == MZ_OK)
                {
                    num_of_file++;
                    
                    do
                    {
                        err = mz_zip_reader_entry_get_info(reader, &zi);
                        
                        if (err == MZ_OK)
                        {
                            relative_path_t relative_path;
                            absolute_path_t sub_path, absolute_path;
                            
                            double compressed_size = zi->compressed_size;
                            double uncompressed_size = zi->uncompressed_size;
                            
#if VERSIONWIN
                            relative_path = relative_path_t(zi->filename);
                            relative_path_t sub_path_utf8 = relative_path;
#else
                            relative_path = absolute_path_t(zi->filename);
                            sub_path = relative_path;
#endif
                            if(charset == CHARSET_AUTOMATIC)
                            {
#if VERSIONMAC
                                if(sniffer)
                                {
                                    numTextEncodings = charset_num;
                                    maxErrs = relative_path.size();
                                    maxFeatures = relative_path.size();
                                    std::vector<ItemCount> _numErrsArray(charset_count);
                                    numErrsArray = &_numErrsArray[0];
                                    std::vector<ItemCount> _numFeaturesArray(charset_count);
                                    ItemCount *numFeaturesArray = &_numFeaturesArray[0];
                                    if(!TECSniffTextEncoding(sniffer,
                                                             (ConstTextPtr)relative_path.c_str(),
                                                             (ByteCount)relative_path.size(),
                                                             encodings,
                                                             numTextEncodings,
                                                             numErrsArray,
                                                             maxErrs,
                                                             numFeaturesArray,
                                                             maxFeatures))
                                    {
                                        RegionCode actualRegion;
                                        TextEncoding actualEncoding;
                                        ByteCount length;
                                        TextEncoding unicode = CreateTextEncoding(kTextEncodingUnicodeDefault,
                                                                                  kTextEncodingDefaultVariant,
                                                                                  kUnicode16BitFormat);
                                        
                                        std::vector<char> buf(len);
                                        if(!GetTextEncodingName(
                                                                encodings[0],
                                                                kTextEncodingFullName,
                                                                0,
                                                                unicode,
                                                                len,
                                                                &length,
                                                                &actualRegion,
                                                                &actualEncoding,
                                                                (TextPtr)&buf[0]))
                                        {
                                            CFStringRef name = CFStringCreateWithCharacters(kCFAllocatorDefault, (const UniChar*)&buf[0], (length/2));
                                            if(name)
                                            {
                                                UInt32 codepage = TextEncodingNameToWindowsCodepage(name);
                                                if(codepage > 0)
                                                {
                                                    convertPathFromCodepage(relative_path, codepage);
                                                    convertPathFromCodepage(sub_path, codepage);
                                                }
                                                CFRelease(name);
                                            }
                                        }
                                    }
                                }
#else
                                if(mlang)
                                {
                                    char *data = (char *)relative_path.c_str();
                                    size_t size = relative_path.size();
                                    int scores = numTextEncodings;
                                    std::vector<DetectEncodingInfo> encodings(scores);
                                    mlang->DetectInputCodepage(MLDETECTCP_NONE, 0, data, (INT *)&size, &encodings[0], &scores);
                                    INT confidence = 0;
                                    
                                    for(int i = 0; i < scores ; ++i)
                                    {
                                        if(encodings[i].nLangID != 0)
                                        {
                                            if(confidence < encodings[i].nConfidence){
                                                codepage = encodings[i].nCodePage;
                                            }
                                        }
                                    }
                                    if(codepage > 0)
                                    {
                                        convertPathFromCodepage(relative_path, codepage, mlang);
                                        convertPathFromCodepage(sub_path_utf8, codepage, mlang);
                                    }
                                }
#endif
                            }else if(charset > 0)
                            {
#if VERSIONMAC
                                convertPathFromCodepage(relative_path, charset);
                                convertPathFromCodepage(sub_path, charset);
#else
                                convertPathFromCodepage(relative_path, charset, mlang);
                                convertPathFromCodepage(sub_path_utf8, charset, mlang);
#endif
                            }
      
#if VERSIONWIN
                            unescape_path(sub_path_utf8);
                            utf8_to_wcs(sub_path_utf8, sub_path);
#endif
                            
                            absolute_path = output;
                            absolute_path+= folder_separator + sub_path;
                            
                            if(use_callback)
                            {
                                
                            }
                            
                            if(relative_path.size() > 1)
                            {
                                if( !ignore_dot || ((relative_path.at(0) != '.') && relative_path.find("/.") == std::string::npos))
                                {
                                    create_parent_folder(absolute_path);
                                    
                                    if(relative_path.at(relative_path.size() - 1) == folder_separator)
                                    {
                                        
                                        create_folder(absolute_path);
                                    }
                                    
                                     bool symbolicLinkCreated = false;
                                    
#if VERSIONMAC
                                    if(with_atttributes){
                                        
                                        if(((zi->external_fa >> 16L) & 0xA000) == 0xA000)
                                        {
   
                                            std::vector<char> _buf(PATH_MAX);
                                            int32_t read = mz_zip_entry_read(h->zip_handle, &_buf[0], PATH_MAX);
                                            if(read > 0)
                                            {
                                                NSString *destinationPath =[[NSString alloc]initWithBytes:&_buf[0] length:len encoding:NSUTF8StringEncoding];
                                                NSString *fullPath = [[NSString alloc]initWithUTF8String:absolute_path.c_str()];
                                                symbolicLinkCreated = [fm createSymbolicLinkAtPath:fullPath withDestinationPath:destinationPath error:nil];
                                                [fullPath release];
                                                [destinationPath release];
                                            }
                                            
                                        }
                                        
                                    }
#endif
                                    if(!symbolicLinkCreated)
                                    {
                                        std::ofstream ofs(absolute_path.c_str(), std::ios::out|std::ios::binary);
                                        
                                        if(ofs.is_open())
                                        {
                                            int32_t read;
                                            
                                            err = mz_zip_entry_read_open(h->zip_handle, h->raw, pass);
                                            
                                            if (err == MZ_OK)
                                            {
                                                while ((read = mz_zip_entry_read(h->zip_handle, &buf[0], BUFFER_SIZE)) > 0)
                                                {
                                                    yield_counter++;
                                                    
                                                    ofs.write((const char *)&buf[0], read);
                                                    
                                                    if((yield_counter % YIELD_FACTOR) == 0)
                                                    {
                                                        PA_YieldAbsolute();
                                                    }
                                                }
                                                
                                                mz_zip_entry_close(h->zip_handle);
                                                
                                            }
                                            ofs.close();                                            
                                        }
                                    }
#if VERSIONMAC
                                    if(with_atttributes)
                                    {
                                        short permission = (zi->external_fa >> 16L) & 0x01FF;
                                        
                                        if(permission)
                                        {
                                            yield_counter++;
                                            
                                            NSDictionary *itemAttributes = [NSDictionary
                                                                            dictionaryWithObject:[NSNumber numberWithShort:permission]
                                                                            forKey:NSFilePosixPermissions];
                                            
                                            NSString *fullPath = [[NSString alloc]initWithUTF8String:absolute_path.c_str()];
                                            [fm setAttributes:itemAttributes ofItemAtPath:fullPath error:nil];
                                            [fullPath release];
                                        }
                                        
                                    }
#endif
                                }
                                
                            }

                            err = mz_zip_reader_goto_next_entry(reader);
                            
                            if (err == MZ_OK)
                            {
                                num_of_file++;
                            }
                        }
                    }
                    while (err == MZ_OK && !abortedByCallbackMethod);
                }
            }
        }
#if VERSIONMAC
        [fm release];
        
        if(sniffer)
        {
            TECDisposeSniffer(sniffer);
        }
#endif
        mz_zip_reader_close(reader);
    }
    
    mz_zip_reader_delete(&reader);
    
#if VERSIONWIN
    if(mlang)
    {
        mlang->Release();
    }
#endif
    
    if(abortedByCallbackMethod){
        returnValue.setIntValue(0);
    }
    
    returnValue.setReturn(pResult);
}

#ifdef WIN32

using namespace std;

int wcs_to_utf8(wstring& wstr, string& str){

    int error = 0;

    int len = WideCharToMultiByte(CP_UTF8, 0, (LPCWSTR)wstr.c_str(), wstr.length(), NULL, 0, NULL, NULL);
    if(len){
        vector<char> buf(len + 1);
        if(WideCharToMultiByte(CP_UTF8, 0, (LPCWSTR)wstr.c_str(), wstr.length(), (LPSTR)&buf[0], len, NULL, NULL)){
            str = string((const char *)&buf[0]);
        }
    }else{
        str = string((const char *)"");
        error = -1;
    }

    return error;

}

int utf8_to_wcs(string& str, std::wstring& wstr)
{
   
    int error = 0; 
    
    int len = MultiByteToWideChar(CP_UTF8, 0, (LPCSTR)str.c_str(), str.length(), NULL, 0);
    if(len){
        vector<char> buf((len + 1) * sizeof(wchar_t));
        if(MultiByteToWideChar(CP_UTF8, 0, (LPCSTR)str.c_str(), str.length(), (LPWSTR)&buf[0], len)){
            wstr = wstring((const wchar_t *)&buf[0]);
        }
    }else{
        wstr = wstring((const wchar_t *)L"");
        error = -1;
    }
    
    return error;   
    
}

void unescape_path(string &path)
{
    wstring wpath;
    utf8_to_wcs(path, wpath);
    unescape_path(wpath);
    wcs_to_utf8(wpath, path);
}

void escape_path(string &path)
{
    wstring wpath;
    utf8_to_wcs(path, wpath);
    escape_path(wpath);
    wcs_to_utf8(wpath, path);
}

void unescape_path(wstring &path)
{
    for (unsigned int i = 0; i < path.size(); ++i)
        if (path.at(i) == '/')
            path.at(i) = L'\\';
}

void escape_path(wstring &path)
{
    for (unsigned int i = 0; i < path.size(); ++i)
        if (path.at(i) == '\\')
            path.at(i) = L'/';
}

void get_subpaths(wstring& path,
                  absolute_paths_t *absolute_paths,
                  relative_paths_t *relative_paths,
				  relative_path_t& folder_name,
                  bool ignore_dot,
                  bool without_enclosing_folder,
                  size_t absolutePathOffset = 0)
{
    
    WIN32_FIND_DATA find;	
    
    HANDLE h = FindFirstFile(path.c_str(), &find);
    
    absolute_path_t absolute_path;
    relative_path_t relative_path;

    if(h != INVALID_HANDLE_VALUE){
			
			unsigned int yield_counter = 0;
			
        do {
            
					yield_counter++;
					if((yield_counter % YIELD_FACTOR) == 0)
					{
						PA_YieldAbsolute();
					}
					
					
            wstring sub_path = find.cFileName;
            
            if((!wcscmp(sub_path.c_str(), L"..")) || (!wcscmp(sub_path.c_str(), L".")))
                continue;		
            
            if(find.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY){
                
                if(!absolutePathOffset){
                    //top level is folder
                    absolutePathOffset = path.size() - 1;

					wcs_to_utf8(sub_path + L"/", folder_name);	

                    if(!without_enclosing_folder){
                        absolute_paths->push_back(path);
                        relative_paths->push_back(folder_name);
                    }

                    get_subpaths(path + L"\\*", 
                                 absolute_paths, 		
                                 relative_paths,       
                                 folder_name,
                                 ignore_dot, 
                                 without_enclosing_folder,
                                 absolutePathOffset);
                    
                }else{
                    //is sub-folder
                    absolute_path = path + sub_path; 
                    
                    wstring base_path = path.substr(0, path.size() - 1).substr(absolutePathOffset + 2);
                    base_path += sub_path;
                    base_path += L"\\";
                    escape_path(base_path);
                    wcs_to_utf8(base_path, relative_path);
					relative_path = folder_name + relative_path;
                    
                    bool is_hidden = (GetFileAttributes(absolute_path.c_str())|FILE_ATTRIBUTE_HIDDEN)|(relative_path.at(0) == '.');
                    
                    if(!ignore_dot || (!is_hidden && relative_path.find("/.") == string::npos)){
                     
                        absolute_paths->push_back(absolute_path);
                        
                        if(!without_enclosing_folder){
                            relative_paths->push_back(relative_path);
                        }else{
                            relative_paths->push_back(relative_path.substr(folder_name.length()));
                        }
                        
                        get_subpaths(path.substr(0, path.size() - 1)  + sub_path + L"\\*", 
                                     absolute_paths, 
                                     relative_paths, 
									 folder_name,
                                     ignore_dot,
                                     without_enclosing_folder,
                                     absolutePathOffset);
                        
                    }
  
                }
                
            }else{
                
                if(!absolutePathOffset){
                    // (over-ride ignore_dot, this is top level)
                    absolute_path = path;// + sub_path;  
                    
                    escape_path(sub_path);
                    wcs_to_utf8(sub_path, relative_path);

                    absolute_paths->push_back(absolute_path);
                    relative_paths->push_back(relative_path);
                    
                }else{
                    
					wstring base_path = path.substr(0, path.size() - 1);
                    absolute_path = base_path + sub_path;  
                    
                    sub_path = base_path.substr(absolutePathOffset + 2) + sub_path;
                    escape_path(sub_path);
                    wcs_to_utf8(sub_path, relative_path);
					relative_path = folder_name + relative_path;

                    if(!ignore_dot || ((relative_path.at(0) != '.') && relative_path.find("/.") == string::npos)){
                        
                        absolute_paths->push_back(absolute_path);
                        
                        if(!without_enclosing_folder){
                            relative_paths->push_back(relative_path);
                        }else{
                            relative_paths->push_back(relative_path.substr(folder_name.length()));
                        }
                    }
  
                }
                
            }		
            
        } while (FindNextFile(h, &find));
        /*
		if(!absolute_paths->size() && absolutePathOffset){
			wstring base_path = path.substr(0, path.size() - 1);
			relative_paths->push_back(folder_name);	
                absolute_paths->push_back(base_path);
		}
        */
        FindClose(h);
        
    }    
    
}
#endif

void convertToString(C_TEXT &fromString, std::string &toString)
{
#ifdef _WIN32
    int len = WideCharToMultiByte(CP_UTF8, 0, (LPCWSTR)fromString.getUTF16StringPtr(), fromString.getUTF16Length(), NULL, 0, NULL, NULL);
    
    if(len){
        std::vector<uint8_t> buf(len + 1);
        if(WideCharToMultiByte(CP_UTF8, 0, (LPCWSTR)fromString.getUTF16StringPtr(), fromString.getUTF16Length(), (LPSTR)&buf[0], len, NULL, NULL)){
            toString = std::string((const char *)&buf[0]);
        }
    }else{
        toString = std::string((const char *)"\0");
    }
#else
    CFStringRef str = CFStringCreateWithCharacters(kCFAllocatorDefault, (const UniChar *)fromString.getUTF16StringPtr(), fromString.getUTF16Length());
    if(str){
        
        size_t size = CFStringGetMaximumSizeForEncoding(CFStringGetLength(str), kCFStringEncodingUTF8) + sizeof(uint8_t);
        std::vector<uint8_t> buf(size);
        CFIndex len = 0;
        CFStringGetBytes(str, CFRangeMake(0, CFStringGetLength(str)), kCFStringEncodingUTF8, 0, true, (UInt8 *)&buf[0], size, &len);
        
        toString = std::string((const char *)&buf[0], len);
        CFRelease(str);
    }
#endif
}

void get_subpaths(absolute_path_t& spath,
                  relative_paths_t *relative_paths,
                  absolute_paths_t *absolute_paths,
                  bool ignore_dot,
                  bool with_atttributes,
                  bool without_enclosing_folder)
{
#if VERSIONMAC
    NSString *path = (NSString *)CFStringCreateWithFileSystemRepresentation(kCFAllocatorDefault, spath.c_str());
    
    //semantically the same string but the result from subpathsOfDirectoryAtPath is wrong if we use this:
    //NSString *path = Param.copyPath();
    //maybe because of trailing nulls?
    
    NSFileManager *fm = [[NSFileManager alloc]init];
    
    BOOL isDirectory = YES;
    
    if(with_atttributes){
        
        NSDictionary *attributes = [fm attributesOfItemAtPath:path error:nil];
        
        if(attributes){
            if([[attributes valueForKey:NSFileType]isEqualToString:NSFileTypeSymbolicLink]
               || [[attributes valueForKey:NSFileType]isEqualToString:NSFileTypeRegular]){
                
                //over-ride ignore_dot, this is top level
                relative_paths->push_back(std::string([[path lastPathComponent]UTF8String]));
                absolute_paths->push_back(spath);
                
            }else
                if([[attributes valueForKey:NSFileType]isEqualToString:NSFileTypeDirectory]){
                    
                    NSString *folderName = [[path lastPathComponent]stringByAppendingString:@"/"];
                    NSString *folderPath = [path stringByDeletingLastPathComponent];
                    if(![[folderPath substringFromIndex:[folderPath length]]isEqualToString:@"/"]){
                        folderPath = [folderPath stringByAppendingString:@"/"];
                    }
                    
                    NSURL *baseUrl = [NSURL fileURLWithPath:path isDirectory:YES];
                    NSString *basePath = [baseUrl path];
                    if(![[basePath substringFromIndex:[basePath length]]isEqualToString:@"/"]){
                        basePath = [basePath stringByAppendingString:@"/"];
                    }
                    
                    if(!without_enclosing_folder){
                        relative_paths->push_back([folderName UTF8String]);
                        absolute_paths->push_back([basePath UTF8String]);
                    }
                    
                    NSDirectoryEnumerator *dirEnum = [fm enumeratorAtURL:baseUrl
                                              includingPropertiesForKeys:[NSArray arrayWithObjects:NSURLIsDirectoryKey, NSURLIsHiddenKey, nil]
                                                                 options:0
                                                            errorHandler:nil];
                    unsigned int yield_counter = 0;
                    while(NSURL *u = [dirEnum nextObject]){
                        
                        yield_counter++;
                        if((yield_counter % YIELD_FACTOR) == 0)
                        {
                            PA_YieldAbsolute();
                        }
                        
                        NSNumber *isDirectory;
                        [u getResourceValue:&isDirectory forKey:NSURLIsDirectoryKey error:nil];
                        
                        NSNumber *isHidden;
                        [u getResourceValue:&isHidden forKey:NSURLIsHiddenKey error:nil];
                        
                        NSString *fullPath = [u path];
                        
                        if([isDirectory boolValue])
                            fullPath = [fullPath stringByAppendingString:@"/"];
                        
                        absolute_path_t absolute_path = [fullPath UTF8String];
                        relative_path_t relative_path = [[fullPath substringFromIndex:[folderPath length]]UTF8String];
                        
                        if(!ignore_dot || (((relative_path.at(0) != '.') && relative_path.find("/.") == std::string::npos) && ![isHidden boolValue])){
                            
                            absolute_paths->push_back(absolute_path);
                            
                            if(!without_enclosing_folder){
                                relative_paths->push_back(relative_path);
                            }else{
                                relative_paths->push_back([[fullPath substringFromIndex:[basePath length]]UTF8String]);
                            }
                        }
                    }
                }
        }//attributes
        
    }else{
        
        if([fm fileExistsAtPath:path isDirectory:&isDirectory]){
            
            if(isDirectory){
                
                NSString *folderName = [[path lastPathComponent]stringByAppendingString:@"/"];
                
                NSURL *baseUrl = [NSURL fileURLWithPath:path isDirectory:YES];
                NSString *basePath = [baseUrl path];
                if(![[basePath substringFromIndex:[basePath length]]isEqualToString:@"/"]){
                    basePath = [basePath stringByAppendingString:@"/"];
                }
                
                NSArray *paths = (NSMutableArray *)[fm subpathsOfDirectoryAtPath:path error:NULL];
                
                if(!without_enclosing_folder){
                    relative_paths->push_back([folderName UTF8String]);
                    absolute_paths->push_back([basePath UTF8String]);
                }
                
                //a folder with contents
                
                for(NSUInteger i = 0; i < [paths count]; i++){
                    
                    
                    if((i % YIELD_FACTOR) == 0)
                    {
                        PA_YieldAbsolute();
                    }
                    
                    NSString *itemPath = [paths objectAtIndex:i];
                    NSString *itemFullPath = [path stringByAppendingPathComponent:itemPath];
                    
                    if([fm fileExistsAtPath:itemFullPath isDirectory:&isDirectory]){
                        
                        if(isDirectory)
                            itemPath = [itemPath stringByAppendingString:@"/"];
                        
                        absolute_path_t absolute_path = [itemFullPath UTF8String];
                        relative_path_t relative_path = [[folderName stringByAppendingString:itemPath]UTF8String];
                        
                        if(!ignore_dot || ((relative_path.at(0) != '.') && relative_path.find("/.") == std::string::npos)){
                            
                            
                            absolute_paths->push_back(absolute_path);
                            
                            if(!without_enclosing_folder){
                                relative_paths->push_back(relative_path);
                            }else{
                                relative_paths->push_back([itemPath UTF8String]);
                            }
                        }
                    }
                }
                
            }else{
                //a file (over-ride ignore_dot, this is top level)
                relative_paths->push_back(std::string([[path lastPathComponent]UTF8String]));
                absolute_paths->push_back(spath);
            }
            
        }
        
    }
    
    [path release];
    [fm release];
    
#else
    relative_path_t folder_name;

    get_subpaths(spath, absolute_paths, relative_paths, folder_name, ignore_dot, without_enclosing_folder);
#endif
}

void get_subpaths(C_TEXT& Param, 
                  relative_paths_t *relative_paths, 
                  absolute_paths_t *absolute_paths, 
                  bool ignore_dot,
                  bool with_atttributes,
                  bool without_enclosing_folder){
    
    relative_paths->clear();
    absolute_paths->clear();
    
    using namespace Json;
    using namespace std;
    
    string paths_json;
    convertToString(Param, paths_json);
    
    CharReaderBuilder builder;
    CharReader *reader = builder.newCharReader();
    Value root;
    string errors;
    
    bool parsingSuccessful;
    
    parsingSuccessful = reader->parse(paths_json.c_str(),
                                      paths_json.c_str() + paths_json.size(),
                                      &root,
                                      &errors);
    delete reader;
    
    vector<string>sources(0);
    
    if (parsingSuccessful)
    {
        if(root.type() == arrayValue)
        {
            for(Value::const_iterator it = root.begin() ; it != root.end() ; ++it)
            {
                if(it->isString())
                {
                    sources.push_back(it->asCString());
                }
            }
        }
    }else
    {
        sources.push_back(paths_json.c_str());
    }
    
    for(size_t i = 0; i < sources.size(); ++i)
    {
        string source = sources.at(i);
        absolute_path_t spath;
        copy_path(source, spath);
        
        get_subpaths(spath, relative_paths, absolute_paths, ignore_dot, with_atttributes, without_enclosing_folder);
    }

}

void Zip(sLONG_PTR *pResult, PackagePtr pParams)
{
    
    C_TEXT Param1;
    C_TEXT Param2;
    C_TEXT Param3;
    C_LONGINT Param4;
    C_LONGINT Param5;
    C_TEXT Param6;
    C_LONGINT Param7;
    C_LONGINT returnValue;
    
    Param1.fromParamAtIndex(pParams, 1);//src
    Param2.fromParamAtIndex(pParams, 2);//dst
    Param3.fromParamAtIndex(pParams, 3);//pass
    Param4.fromParamAtIndex(pParams, 4);//level
    Param5.fromParamAtIndex(pParams, 5);//options
    Param6.fromParamAtIndex(pParams, 6);//callback
    Param7.fromParamAtIndex(pParams, 7);//codepage
    
    //src
    absolute_paths_t absolute_paths;
    relative_paths_t relative_paths;
    relative_path_t input_file_name;
    
    //pass
    std::string password;
    convertToString(Param3, password);
    bool with_password = (password.length() != 0);
    const char *pass = with_password ? password.c_str() : NULL;
    
    //dst
    CUTF8String output_path;
    Param2.copyPath(&output_path);
    const char *output = (const char*)output_path.c_str();

    //level
    unsigned int level = Param4.getIntValue();
    if(!level){
        level = MZ_COMPRESS_LEVEL_DEFAULT;
    }else if (level > 10){
        level = 9;
    }
    
    unsigned int flags = Param5.getIntValue();
    
    bool ignore_dot = !!(flags & 1L);
    
#if VERSIONMAC
    bool with_atttributes = !!(flags & 2L);
#else
    bool with_atttributes = false;
#endif
    
    bool without_enclosing_folder = !!(flags & 4L);
    bool with_encyption = !!(flags & 8L);
    
    bool with_bz2 = !!(flags & 16L);
    bool with_lzma = !!(flags & 32L);
    
#if VERSIONWIN
    IMultiLanguage2 *mlang = NULL;
    CoCreateInstance(CLSID_CMultiLanguage, NULL, CLSCTX_INPROC_SERVER, IID_IMultiLanguage2, (void **)&mlang);
#endif
    
    //callback
    method_id_t methodId = PA_GetMethodID((PA_Unichar *)Param6.getUTF16StringPtr());
    bool abortedByCallbackMethod = false;
    bool use_callback = Param6.getUTF16Length();
    
    int charset = Param7.getIntValue();
    
    get_subpaths(Param1, &relative_paths, &absolute_paths, ignore_dot, with_atttributes, without_enclosing_folder);
    
    if(relative_paths.size()){
        
        void *writer = NULL;
        int16_t compress_method = MZ_COMPRESS_METHOD_DEFLATE;
        
        if(with_bz2)
        {
            compress_method = MZ_COMPRESS_METHOD_BZIP2;
        }
        
        if(with_lzma)
        {
            compress_method = MZ_COMPRESS_METHOD_LZMA;
        }
        
        unsigned int yield_counter = 0;
        
        mz_zip_writer_create(&writer);
        
        mz_zip_writer *h = (mz_zip_writer *)writer;
        std::vector<uint8_t> buf(BUFFER_SIZE);
        
        double number_entry = relative_paths.size();
        
        if(with_password)
        {
            mz_zip_writer_set_password(writer, pass);
        }
        
        mz_zip_writer_set_compress_method(writer, compress_method);
        mz_zip_writer_set_compress_level(writer, level);

        mz_zip_writer_set_aes(writer, with_encyption);
        
        int32_t err = mz_zip_writer_open_file(writer, output, 0, 0);
        
        if (err == MZ_OK)
        {
            returnValue.setIntValue(1);
            
#if VERSIONMAC
            NSFileManager *fm = [[NSFileManager alloc]init];
#endif
            for (unsigned int i = 0; i < relative_paths.size(); ++i)
            {
                relative_path_t relative_path = relative_paths.at(i);
                absolute_path_t absolute_path = absolute_paths.at(i);
                relative_path_t relative_path_utf8 = relative_path;
                relative_path_t absolute_path_utf8;
                relative_path_t symbolic_path_utf8;
                
                bool isSymbolicLink = false;
#if VERSIONMAC
                absolute_path_utf8 = absolute_path;
#else
                wcs_to_utf8(absolute_path, absolute_path_utf8);
#endif
                const char *path = absolute_path_utf8.c_str();
                
                mz_zip_file zi;
                memset(&zi, 0, sizeof(zi));

                zi.version_madeby = MZ_VERSION_MADEBY;
                
#if VERSIONMAC
                if(with_atttributes)
                {
                    NSString *symbolicPath = (NSString *)CFStringCreateWithFileSystemRepresentation(kCFAllocatorDefault, absolute_path.c_str());
                    NSString *destinationPath = [fm destinationOfSymbolicLinkAtPath:symbolicPath error:nil];
                    if(destinationPath){
                        symbolic_path_utf8 = relative_path_t([destinationPath UTF8String]);
                        [symbolicPath release];
                        isSymbolicLink = TRUE;
                    }
                }
#endif
                if(charset > 0)
                {
#if VERSIONMAC
                    convertPathToCodepage(relative_path, charset);
#else
                    convertPathToCodepage(relative_path, charset, mlang);
#endif
                    zi.flag &= ~MZ_ZIP_FLAG_UTF8;
                }else
                {
                    zi.flag |=  MZ_ZIP_FLAG_UTF8;
                }
                zi.filename = relative_path.c_str();
                zi.uncompressed_size = mz_os_get_file_size(path);
                
                zi.compression_method = compress_method;
                if(with_encyption)
                {
                    zi.aes_version = MZ_AES_VERSION;
                }
                mz_os_get_file_date(path,
                                    &zi.modified_date,
                                    &zi.accessed_date,
                                    &zi.creation_date);
                
                mz_os_get_file_attribs(path, &zi.external_fa);
#if VERSIONMAC
                if(with_atttributes)
                {
                    NSDictionary *attributes = [fm attributesOfItemAtPath:
                                                [NSString stringWithUTF8String:(const char *)absolute_path.c_str()]error:nil];
                    if(attributes)
                    {
                        
                        if([[attributes valueForKey:NSFileType]isEqualToString:NSFileTypeCharacterSpecial])
                        {
                            zi.external_fa = 0x20000000;
                        }else
                            if([[attributes valueForKey:NSFileType]isEqualToString:NSFileTypeDirectory])
                            {
                                zi.external_fa = 0x40000000;
                            }else
                                if([[attributes valueForKey:NSFileType]isEqualToString:NSFileTypeBlockSpecial])
                                {
                                    zi.external_fa = 0x60000000;
                                }else
                                    if([[attributes valueForKey:NSFileType]isEqualToString:NSFileTypeRegular])
                                    {
                                        zi.external_fa = 0x80000000;
                                    }else
                                        if(([[attributes valueForKey:NSFileType]isEqualToString:NSFileTypeSymbolicLink]))
                                        {
                                            zi.external_fa = 0xA0000000;
                                        }else
                                            if([[attributes valueForKey:NSFileType]isEqualToString:NSFileTypeSocket])
                                            {
                                                zi.external_fa = 0xC0000000;
                                            }
                        zi.external_fa |= ([[attributes valueForKey:NSFilePosixPermissions]shortValue] << 16L);
                        
                    }//attributes

                }//with_atttributes
#endif
                bool is_dir = (mz_zip_attrib_is_dir(zi.external_fa, zi.version_madeby) == MZ_OK);
                
                if(with_password)
                {
                    if(is_dir)
                    {
                        mz_zip_writer_set_password(writer, NULL);/* mac archiver does not process password for folder */
                    }else
                    {
                        mz_zip_writer_set_password(writer, pass);
                    }
                }
                
                if(mz_zip_writer_entry_open(writer, &zi) == MZ_OK)
                {
                    if (!is_dir)
                    {
                        if(with_password)
                        {
                            mz_zip_writer_set_password(writer, pass);
                        }
                        std::ifstream ifs(absolute_path.c_str(), std::ios::in|std::ios::binary);
                        if(ifs.is_open())
                        {
                            if(isSymbolicLink)
                            {
                                yield_counter++;
                                int32_t read = (int32_t)symbolic_path_utf8.length();
                                int32_t written = mz_zip_entry_write(h->zip_handle, symbolic_path_utf8.c_str(), read);
                                if (written != read)/* MZ_STREAM_ERROR */
                                {
                                    returnValue.setIntValue(0);
                                    break;
                                }
                            }else
                            {
                                while(ifs.good())
                                {
                                    yield_counter++;
                                    if((yield_counter % YIELD_FACTOR) == 0)
                                    {
                                        PA_YieldAbsolute();
                                    }
                                    ifs.read((char *)&buf[0], BUFFER_SIZE);
                                    int32_t read = (int32_t)ifs.gcount();
                                    int32_t written = mz_zip_entry_write(h->zip_handle, &buf[0], read);
                                    if (written != read)/* MZ_STREAM_ERROR */
                                    {
                                        returnValue.setIntValue(0);
                                        break;
                                    }
                                }
                            }

                            ifs.close();
                        }
                    }
                    err = mz_zip_writer_entry_close(writer);
                    
                    if(use_callback)
                    {
                        if(methodId)
                        {
                            PA_Variable    params[4];
                            params[0] = PA_CreateVariable(eVK_Unistring);
                            params[1] = PA_CreateVariable(eVK_Unistring);
                            params[2] = PA_CreateVariable(eVK_Real);
                            params[3] = PA_CreateVariable(eVK_Real);
                            
                            C_TEXT tempUstr;
                            tempUstr.setUTF8String((const uint8_t *)relative_path_utf8.c_str(), (uint32_t)relative_path_utf8.length());
                            PA_Unistring methodParam1 = PA_CreateUnistring((PA_Unichar *)tempUstr.getUTF16StringPtr());
                            PA_SetStringVariable(&params[0], &methodParam1);
                            tempUstr.setUTF8String((const uint8_t *)absolute_path.c_str(), (uint32_t)absolute_path.length());
                            PA_Unistring methodParam2 = PA_CreateUnistring((PA_Unichar *)tempUstr.getUTF16StringPtr());
                            PA_SetStringVariable(&params[1], &methodParam2);
                            
                            PA_SetRealVariable(&params[2], i+1);
                            PA_SetRealVariable(&params[3], number_entry);
                            
                            PA_Variable result = PA_ExecuteMethodByID(methodId, params, 4);
                            
                            if(PA_GetVariableKind(result) == eVK_Boolean)
                                abortedByCallbackMethod = PA_GetBooleanVariable(result);
                            
                            PA_ClearVariable(&params[0]);
                            PA_ClearVariable(&params[1]);
                            PA_ClearVariable(&params[2]);
                            PA_ClearVariable(&params[3]);
                        }else
                        {
                            PA_Variable    params[6];
                            params[2] = PA_CreateVariable(eVK_Unistring);
                            params[3] = PA_CreateVariable(eVK_Unistring);
                            params[4] = PA_CreateVariable(eVK_Real);
                            params[5] = PA_CreateVariable(eVK_Real);
                            
                            params[0] = PA_CreateVariable(eVK_Unistring);
                            PA_Unistring _methodName = PA_CreateUnistring((PA_Unichar *)Param6.getUTF16StringPtr());
                            PA_SetStringVariable(&params[0], &_methodName);
                            
                            params[1] = PA_CreateVariable(eVK_Boolean);
                            PA_SetBooleanVariable(&params[1], false);
                            
                            C_TEXT tempUstr;
                            tempUstr.setUTF8String((const uint8_t *)relative_path_utf8.c_str(), (uint32_t)relative_path_utf8.length());
                            PA_Unistring methodParam1 = PA_CreateUnistring((PA_Unichar *)tempUstr.getUTF16StringPtr());
                            PA_SetStringVariable(&params[2], &methodParam1);
                            tempUstr.setUTF8String((const uint8_t *)absolute_path.c_str(), (uint32_t)absolute_path.length());
                            PA_Unistring methodParam2 = PA_CreateUnistring((PA_Unichar *)tempUstr.getUTF16StringPtr());
                            PA_SetStringVariable(&params[3], &methodParam2);
                            
                            PA_SetRealVariable(&params[4], i+1);
                            PA_SetRealVariable(&params[5], number_entry);
                            PA_ExecuteCommandByID(1007, params, 6);
                            
                            abortedByCallbackMethod = PA_GetBooleanVariable(params[1]);
                            
                            PA_ClearVariable(&params[0]);
                            PA_ClearVariable(&params[1]);
                            PA_ClearVariable(&params[3]);
                            PA_ClearVariable(&params[4]);
                            PA_ClearVariable(&params[5]);
                        }
                        
                        if(abortedByCallbackMethod)
                        {
                            i = number_entry;
                        }
                    }
                }/* mz_zip_writer_entry_open */
                
            }/* for (unsigned int i = 0; i < relative_paths.size(); ++i) */
#if VERSIONMAC
            [fm release];
#endif
             mz_zip_writer_close(writer);
        }/*  if (err == MZ_OK) */
        mz_zip_writer_delete(&writer);
    }
    
#if VERSIONWIN
    if(mlang)
    {
        mlang->Release();
    }
#endif
    
    returnValue.setReturn(pResult);
}

#pragma mark -

bool create_folder(absolute_path_t& absolute_path){
    
    bool success = false;
    
#if VERSIONMAC
    NSString *path = (NSString *)CFStringCreateWithFileSystemRepresentation(kCFAllocatorDefault, absolute_path.c_str());
    NSFileManager *fm = [[NSFileManager alloc]init];
    success = [fm createDirectoryAtPath:path 
            withIntermediateDirectories:YES
                             attributes:nil
                                  error:NULL];	
    [path release];					
    [fm release];			
#else
    success = SHCreateDirectory(NULL, (PCWSTR)absolute_path.c_str());				
#endif	
    
    return success;
}

void create_parent_folder(absolute_path_t& absolute_path){
#if VERSIONMAC
    NSString *filePath = (NSString *)CFStringCreateWithFileSystemRepresentation(kCFAllocatorDefault, absolute_path.c_str());
    absolute_path_t folderPath = absolute_path_t([[filePath stringByDeletingLastPathComponent]fileSystemRepresentation]);
    create_folder(folderPath);
    [filePath release];
#else	
    wchar_t	fDrive[_MAX_DRIVE],
    fDir[_MAX_DIR],
    fName[_MAX_FNAME],
    fExt[_MAX_EXT];
    _wsplitpath_s(absolute_path.c_str(), fDrive, fDir, fName, fExt);	
    absolute_path_t folderPath = fDrive;
    folderPath += fDir;
    create_folder(folderPath);
#endif	
}

void copy_path(std::string& t, absolute_path_t& p){
    C_TEXT u;
    u.setUTF8String((const uint8_t *)t.c_str(), (uint32_t)t.length());
    copy_path(u, p);
}

void copy_path(C_TEXT& t, absolute_path_t& p){
#if VERSIONMAC	
    NSString *str = t.copyUTF16String();
    NSURL *u = (NSURL *)CFURLCreateWithFileSystemPath(kCFAllocatorDefault, (CFStringRef)str, kCFURLHFSPathStyle, false);
    
    if(u){
        NSString *path = (NSString *)CFURLCopyFileSystemPath((CFURLRef)u, kCFURLPOSIXPathStyle);
        CFIndex size = CFStringGetMaximumSizeOfFileSystemRepresentation((CFStringRef)path);
        std::vector<uint8_t> buf(size);		
        [path getFileSystemRepresentation:(char *)&buf[0] maxLength:size];
        p = std::string((char *)&buf[0]);
        [path release];
        [u release];
    }	
    
    [str release];
    
#else
    p = std::wstring((wchar_t *)t.getUTF16StringPtr());
    
    if(p.at(p.size() - 1) == L'\\')
        p = p.substr(0, p.size() - 1);
#endif	
}
