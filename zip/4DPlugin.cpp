/* --------------------------------------------------------------------------------
 #
 #	4DPlugin.cpp
 #	source generated by 4D Plugin Wizard
 #	Project : Zip
 #	author : miyako
 #	2016/03/08
 #
 # --------------------------------------------------------------------------------*/


#include "4DPluginAPI.h"
#include "4DPlugin.h"

//#define zipOpenNewFileInZip3_64_noAES zipOpenNewFileInZip3_64
//#define zipOpenNewFileInZip64_noAES zipOpenNewFileInZip64
//#define zipWriteInFileInZip_noAES zipWriteInFileInZip
//#define zipCloseFileInZip_noAES zipCloseFileInZip

void PluginMain(PA_long32 selector, PA_PluginParameters params)
{
	try
	{
		PA_long32 pProcNum = selector;
		sLONG_PTR *pResult = (sLONG_PTR *)params->fResult;
		PackagePtr pParams = (PackagePtr)params->fParameters;

		CommandDispatcher(pProcNum, pResult, pParams); 
	}
	catch(...)
	{

	}
}

void CommandDispatcher (PA_long32 pProcNum, sLONG_PTR *pResult, PackagePtr pParams)
{
	switch(pProcNum)
	{
// --- Zip

		case 1 :
			Unzip(pResult, pParams);
			break;

		case 2 :
			Zip(pResult, pParams);
			break;

	}
}

// -------------------------------------- Zip -------------------------------------

void Unzip(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_TEXT Param1;
	C_TEXT Param2;
	C_TEXT Param3;
	C_LONGINT Param4;
    C_TEXT Param5;
	C_LONGINT returnValue;

	Param1.fromParamAtIndex(pParams, 1);
	Param2.fromParamAtIndex(pParams, 2);
	Param3.fromParamAtIndex(pParams, 3);
	Param4.fromParamAtIndex(pParams, 4);
    Param5.fromParamAtIndex(pParams, 5);
    
    //pass
    CUTF8String password;
    Param3.copyUTF8String(&password);
    
    //src, dst
#if VERSIONMAC
    CUTF8String input_path, output_path;
    Param1.copyPath(&input_path);
    Param2.copyPath(&output_path);
    const char *input = (const char*)input_path.c_str();
    const char *output = (const char*)output_path.c_str();
#else
    const wchar_t *input = (const wchar_t*)Param1.getUTF16StringPtr();
    const wchar_t *output = (const wchar_t*)Param2.getUTF16StringPtr();    
#endif  
    
    unsigned int flags = Param4.getIntValue();
    
    bool ignore_dot = !!(flags & 1L);
    
#if VERSIONMAC    
    bool with_atttributes = !!(flags & 2L);
#else
    bool with_atttributes = false;    
#endif

    //callback
    method_id_t methodId = PA_GetMethodID((PA_Unichar *)Param5.getUTF16StringPtr());
    bool abortedByCallbackMethod = false;
    
    unzFile hUnzip = unzOpen64(input);
    
    if (hUnzip){
        
        returnValue.setIntValue(1);
        
        unz_file_info64 fileInfo;
        unz_global_info64 globalInfo;
        unz64_file_pos filePos;
        
        double number_entry;
        
        bool isCallbackActive = false;
        
        if(methodId){
            if(unzGetGlobalInfo64(hUnzip, &globalInfo) == UNZ_OK){
                number_entry = globalInfo.number_entry;
                isCallbackActive = true;
            }
        }
        
        std::vector<uint8_t> szConFilename(PATH_MAX);
        
        relative_path_t relative_path;
        absolute_path_t sub_path, absolute_path;

#if VERSIONMAC
            NSFileManager *fm = [[NSFileManager alloc]init];
#endif  
        
        do {
            
            PA_YieldAbsolute();
            
            if (unzGetCurrentFileInfo64(hUnzip, &fileInfo, (char *)&szConFilename[0], PATH_MAX, NULL, 0, NULL, 0) != UNZ_OK){
                returnValue.setIntValue(0);
                break;
            }

            get_relative_path(&szConFilename[0], sub_path, relative_path);

            absolute_path = output;
            absolute_path+= folder_separator + sub_path;
            
            //callback
            if(isCallbackActive){
                
                double compressed_size = fileInfo.compressed_size;
                double uncompressed_size = fileInfo.uncompressed_size;
                    
                if(unzGetFilePos64(hUnzip, &filePos) == UNZ_OK){
                
                    double num_of_file = filePos.num_of_file;

                    PA_Variable	params[6];
                    params[0] = PA_CreateVariable(eVK_Unistring);
                    params[1] = PA_CreateVariable(eVK_Unistring);
                    params[2] = PA_CreateVariable(eVK_Real);
                    params[3] = PA_CreateVariable(eVK_Real);
                    params[4] = PA_CreateVariable(eVK_Real);
                    params[5] = PA_CreateVariable(eVK_Real);
                    C_TEXT tempUstr;
                    tempUstr.setUTF8String((const uint8_t *)relative_path.c_str(), relative_path.length());
                    PA_Unistring methodParam1 = PA_CreateUnistring((PA_Unichar *)tempUstr.getUTF16StringPtr());
                    PA_SetStringVariable(&params[0], &methodParam1);
                    tempUstr.setUTF8String((const uint8_t *)absolute_path.c_str(), absolute_path.length());
                    PA_Unistring methodParam2 = PA_CreateUnistring((PA_Unichar *)tempUstr.getUTF16StringPtr());
                    PA_SetStringVariable(&params[1], &methodParam2);
                    
                    PA_SetRealVariable(&params[2], num_of_file);
                    PA_SetRealVariable(&params[3], number_entry);
                    PA_SetRealVariable(&params[4], compressed_size);
                    PA_SetRealVariable(&params[5], uncompressed_size);  
                          
                    PA_Variable result = PA_ExecuteMethodByID(methodId, params, 6);
                    PA_DisposeUnistring(&methodParam1);
                    PA_DisposeUnistring(&methodParam2);
                    
                    if(PA_GetVariableKind(result) == eVK_Boolean){
                        
                        abortedByCallbackMethod = PA_GetBooleanVariable(result);
                              
                    }
                
                }

            } 

            if(relative_path.size() > 1){
                if( !ignore_dot || ((relative_path.at(0) != '.') && relative_path.find("/.") == std::string::npos)){
                    
                    create_parent_folder(absolute_path);
                    
                    if(relative_path.at(relative_path.size() - 1) == folder_separator){
                    
                        create_folder(absolute_path);
                        
                    }

                    if(password.length()){
                        if(unzOpenCurrentFilePassword(hUnzip, (const char *)password.c_str()) != UNZ_OK){
                            returnValue.setIntValue(0);
                            break;
                        }  
                    }else{ 
                        if(unzOpenCurrentFile(hUnzip) != UNZ_OK){
                            returnValue.setIntValue(0);
                            break;
                        }
                    }
                    
                    bool symbolicLinkCreated = false;
#if VERSIONMAC                     
                    if(with_atttributes){
                    
                        if(((fileInfo.external_fa >> 16L) & 0xA000) == 0xA000){
                        
                            std::vector<char> buf(PATH_MAX);
                            int len = unzReadCurrentFile(hUnzip, &buf[0], PATH_MAX);
                            
                            if(len > 0){
                                NSString *destinationPath =[[NSString alloc]initWithBytes:&buf[0] length:len encoding:NSUTF8StringEncoding];
                                NSString *fullPath = [[NSString alloc]initWithUTF8String:absolute_path.c_str()];
                                symbolicLinkCreated = [fm createSymbolicLinkAtPath:fullPath withDestinationPath:destinationPath error:nil];
                                [fullPath release];
                                [destinationPath release];
                            }                        
                        
                        }
                         
                    }
#endif 
                    if(!symbolicLinkCreated){
                        std::ofstream ofs(absolute_path.c_str(), std::ios::out|std::ios::binary);
                        
                        if(ofs.is_open()){
                            
                            std::vector<uint8_t> buf(BUFFER_SIZE);
                            std::streamsize size;
                            
                            while ((size = unzReadCurrentFile(hUnzip, &buf[0], BUFFER_SIZE)) > 0){
                                PA_YieldAbsolute();
                                ofs.write((const char *)&buf[0], size);
                            }
                            
                            ofs.close();
                            
                        }                    
                    
                    }
                    
#if VERSIONMAC  
                    if(with_atttributes){
                    
                        short permission = (fileInfo.external_fa >> 16L) & 0x01FF;
                        
                        if(permission){
                        
                            NSDictionary *itemAttributes = [NSDictionary
                                                            dictionaryWithObject:[NSNumber numberWithShort:permission]
                                                            forKey:NSFilePosixPermissions];
                            
                            NSString *fullPath = [[NSString alloc]initWithUTF8String:absolute_path.c_str()];
                            [fm setAttributes:itemAttributes ofItemAtPath:fullPath error:nil];
                            [fullPath release];
                            
                        }

                    }                    
#endif 
                }   
                
            }

            unzCloseCurrentFile(hUnzip);
            
        } while (!abortedByCallbackMethod && (unzGoToNextFile(hUnzip) != UNZ_END_OF_LIST_OF_FILE));
 
#if VERSIONMAC
            [fm release];
#endif         
                      
        unzClose(hUnzip);	
    }     
    
    if(abortedByCallbackMethod){
        returnValue.setIntValue(0);
    }   
                            
	returnValue.setReturn(pResult);
}

#ifdef WIN32

using namespace std;

int wcs_to_utf8(wstring& wstr, string& str){
   
    int error = 0; 
    
    int len = WideCharToMultiByte(CP_UTF8, 0, (LPCWSTR)wstr.c_str(), wstr.length(), NULL, 0, NULL, NULL);
    if(len){
        vector<char> buf(len + 1);
        if(WideCharToMultiByte(CP_UTF8, 0, (LPCWSTR)wstr.c_str(), wstr.length(), (LPSTR)&buf[0], len, NULL, NULL)){
            str = string((const char *)&buf[0]);
        }
    }else{
        str = string((const char *)"");
        error = -1;
    }
    
    return error;   
    
}

int utf8_to_wcs(string& str, wstring& wstr)
{
   
    int error = 0; 
    
    int len = MultiByteToWideChar(CP_UTF8, 0, (LPCSTR)str.c_str(), str.length(), NULL, 0);
    if(len){
        vector<char> buf((len + 1) * sizeof(wchar_t));
        if(MultiByteToWideChar(CP_UTF8, 0, (LPCSTR)str.c_str(), str.length(), (LPWSTR)&buf[0], len)){
            wstr = wstring((const wchar_t *)&buf[0]);
        }
    }else{
        wstr = wstring((const wchar_t *)L"");
        error = -1;
    }
    
    return error;   
    
}

void unescape_path(string &path)
{
    wstring wpath;
    utf8_to_wcs(path, wpath);
    unescape_path(wpath);
    wcs_to_utf8(wpath, path);
}

void escape_path(string &path)
{
    wstring wpath;
    utf8_to_wcs(path, wpath);
    escape_path(wpath);
    wcs_to_utf8(wpath, path);
}

void unescape_path(wstring &path)
{
    for (unsigned int i = 0; i < path.size(); ++i)
        if (path.at(i) == '/')
            path.at(i) = L'\\';
}

void escape_path(wstring &path)
{
    for (unsigned int i = 0; i < path.size(); ++i)
        if (path.at(i) == '\\')
            path.at(i) = L'/';
}

void get_subpaths(wstring& path,
                  absolute_paths_t *absolute_paths,
                  relative_paths_t *relative_paths,
				  relative_path_t& folder_name,
                  bool ignore_dot,
                  bool without_enclosing_folder,
                  size_t absolutePathOffset = 0)
{
    
    WIN32_FIND_DATA find;	
    
    HANDLE h = FindFirstFile(path.c_str(), &find);
    
    absolute_path_t absolute_path;
    relative_path_t relative_path;

    if(h != INVALID_HANDLE_VALUE){
        
        do {
            
            PA_YieldAbsolute();
            
            wstring sub_path = find.cFileName;	
            
            if((!wcscmp(sub_path.c_str(), L"..")) || (!wcscmp(sub_path.c_str(), L".")))
                continue;		
            
            if(find.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY){
                
                if(!absolutePathOffset){
                    //top level is folder
                    absolutePathOffset = path.size() - 1;

					wcs_to_utf8(sub_path + L"/", folder_name);	

                    if(!without_enclosing_folder){
                        absolute_paths->push_back(path);
                        relative_paths->push_back(folder_name);
                    }

                    get_subpaths(path + L"\\*", 
                                 absolute_paths, 		
                                 relative_paths,       
                                 folder_name,
                                 ignore_dot, 
                                 without_enclosing_folder,
                                 absolutePathOffset);
                    
                }else{
                    //is sub-folder
                    absolute_path = path + sub_path; 
                    
                    wstring base_path = path.substr(0, path.size() - 1).substr(absolutePathOffset + 2);
                    base_path += sub_path;
                    base_path += L"\\";
                    escape_path(base_path);
                    wcs_to_utf8(base_path, relative_path);
					relative_path = folder_name + relative_path;

                    if(!ignore_dot || ((relative_path.at(0) != '.') && relative_path.find("/.") == string::npos)){
                     
                        absolute_paths->push_back(absolute_path);
                        
                        if(!without_enclosing_folder){
                            relative_paths->push_back(relative_path);
                        }else{
                            relative_paths->push_back(relative_path.substr(folder_name.length()));
                        }
                        
                        get_subpaths(path.substr(0, path.size() - 1)  + sub_path + L"\\*", 
                                     absolute_paths, 
                                     relative_paths, 
									 folder_name,
                                     ignore_dot,
                                     without_enclosing_folder,
                                     absolutePathOffset);
                        
                    }
  
                }
                
            }else{
                
                if(!absolutePathOffset){
                    // (over-ride ignore_dot, this is top level)
                    absolute_path = path;// + sub_path;  
                    
                    escape_path(sub_path);
                    wcs_to_utf8(sub_path, relative_path);

                    absolute_paths->push_back(absolute_path);
                    relative_paths->push_back(relative_path);
                    
                }else{
                    
					wstring base_path = path.substr(0, path.size() - 1);
                    absolute_path = base_path + sub_path;  
                    
                    sub_path = base_path.substr(absolutePathOffset + 2) + sub_path;
                    escape_path(sub_path);
                    wcs_to_utf8(sub_path, relative_path);
					relative_path = folder_name + relative_path;

                    if(!ignore_dot || ((relative_path.at(0) != '.') && relative_path.find("/.") == string::npos)){
                        
                        absolute_paths->push_back(absolute_path);
                        
                        if(!without_enclosing_folder){
                            relative_paths->push_back(relative_path);
                        }else{
                            relative_paths->push_back(relative_path.substr(folder_name.length()));
                        }
                    }
  
                }
                
            }		
            
        } while (FindNextFile(h, &find));
        /*
		if(!absolute_paths->size() && absolutePathOffset){
			wstring base_path = path.substr(0, path.size() - 1);
			relative_paths->push_back(folder_name);	
                absolute_paths->push_back(base_path);
		}
        */
        FindClose(h);
        
    }    
    
}
#endif

void get_subpaths(C_TEXT& Param, 
                  relative_paths_t *relative_paths, 
                  absolute_paths_t *absolute_paths, 
                  bool ignore_dot,
                  bool with_atttributes,
                  bool without_enclosing_folder){
    
    relative_paths->clear();
    absolute_paths->clear();
    
#if VERSIONMAC
    
    std::string spath;
    copy_path(Param, spath);
    NSString *path = (NSString *)CFStringCreateWithFileSystemRepresentation(kCFAllocatorDefault, spath.c_str());	
    
    //semantically the same string but the result from subpathsOfDirectoryAtPath is wrong if we use this:
    //NSString *path = Param.copyPath();
    
    NSFileManager *fm = [[NSFileManager alloc]init];
    
    BOOL isDirectory = YES;
    
    if(with_atttributes){
    
        NSDictionary *attributes = [fm attributesOfItemAtPath:path error:nil];
        
        if(attributes){
            if([[attributes valueForKey:NSFileType]isEqualToString:NSFileTypeSymbolicLink] 
            || [[attributes valueForKey:NSFileType]isEqualToString:NSFileTypeRegular]){
                
                //over-ride ignore_dot, this is top level
                relative_paths->push_back(std::string([[path lastPathComponent]UTF8String]));
                absolute_paths->push_back(spath);
                
            }else
            if([[attributes valueForKey:NSFileType]isEqualToString:NSFileTypeDirectory]){
            
                NSString *folderName = [[path lastPathComponent]stringByAppendingString:@"/"];
                NSString *folderPath = [path stringByDeletingLastPathComponent];
                if(![[folderPath substringFromIndex:[folderPath length]]isEqualToString:@"/"]){
                    folderPath = [folderPath stringByAppendingString:@"/"];
                }
                
                NSURL *baseUrl = [NSURL fileURLWithPath:path isDirectory:YES]; 
                NSString *basePath = [baseUrl path];
                if(![[basePath substringFromIndex:[basePath length]]isEqualToString:@"/"]){
                    basePath = [basePath stringByAppendingString:@"/"];
                }
                
                if(!without_enclosing_folder){
                    relative_paths->push_back([folderName UTF8String]);	
                    absolute_paths->push_back([basePath UTF8String]);
                }
                                
                NSDirectoryEnumerator *dirEnum = [fm enumeratorAtURL:baseUrl 
                includingPropertiesForKeys:[NSArray arrayWithObjects:NSURLIsDirectoryKey, NSURLIsHiddenKey, nil]
                options:0
                errorHandler:nil];
                
                while(NSURL *u = [dirEnum nextObject]){
                
                    PA_YieldAbsolute();
                    
                    NSNumber *isDirectory;
                    [u getResourceValue:&isDirectory forKey:NSURLIsDirectoryKey error:nil];
                    
                    NSNumber *isHidden;
                    [u getResourceValue:&isHidden forKey:NSURLIsHiddenKey error:nil];
                    
                    NSString *fullPath = [u path];

                    if([isDirectory boolValue])
                            fullPath = [fullPath stringByAppendingString:@"/"];
                       
                    absolute_path_t absolute_path = [fullPath UTF8String];
                    relative_path_t relative_path = [[fullPath substringFromIndex:[folderPath length]]UTF8String];
                    
                    if(!ignore_dot || (((relative_path.at(0) != '.') && relative_path.find("/.") == std::string::npos) && ![isHidden boolValue])){
                    
                        absolute_paths->push_back(absolute_path);
                        
                        if(!without_enclosing_folder){
                            relative_paths->push_back(relative_path);	
                        }else{
                            relative_paths->push_back([[fullPath substringFromIndex:[basePath length]]UTF8String]);	
                        }
                    }
                } 
            }
        }//attributes
        
    }else{
    
        if([fm fileExistsAtPath:path isDirectory:&isDirectory]){
            
            if(isDirectory){
                
                NSString *folderName = [[path lastPathComponent]stringByAppendingString:@"/"];

                NSURL *baseUrl = [NSURL fileURLWithPath:path isDirectory:YES]; 
                NSString *basePath = [baseUrl path];
                if(![[basePath substringFromIndex:[basePath length]]isEqualToString:@"/"]){
                    basePath = [basePath stringByAppendingString:@"/"];
                }

                NSArray *paths = (NSMutableArray *)[fm subpathsOfDirectoryAtPath:path error:NULL];
                
                if(!without_enclosing_folder){
                    relative_paths->push_back([folderName UTF8String]);	
                    absolute_paths->push_back([basePath UTF8String]);
                }
                
                //a folder with contents
                for(NSUInteger i = 0; i < [paths count]; i++){
                    
                    PA_YieldAbsolute();
                    
                    NSString *itemPath = [paths objectAtIndex:i];   
                    NSString *itemFullPath = [path stringByAppendingPathComponent:itemPath];  
                    
                    if([fm fileExistsAtPath:itemFullPath isDirectory:&isDirectory]){
                        
                        if(isDirectory)
                            itemPath = [itemPath stringByAppendingString:@"/"];
                        
                        absolute_path_t absolute_path = [itemFullPath UTF8String];
                        relative_path_t relative_path = [[folderName stringByAppendingString:itemPath]UTF8String];
                        
                        if(!ignore_dot || ((relative_path.at(0) != '.') && relative_path.find("/.") == std::string::npos)){
                        
                            	
                            absolute_paths->push_back(absolute_path);
                            
                            if(!without_enclosing_folder){
                                relative_paths->push_back(relative_path);	
                            }else{
                                relative_paths->push_back([itemPath UTF8String]);	
                            }
                        }
                    }				    
                }
                
            }else{	
                //a file (over-ride ignore_dot, this is top level)
                relative_paths->push_back(std::string([[path lastPathComponent]UTF8String]));
                absolute_paths->push_back(spath);
            }
            
        }    
            
    }
    
    [path release];	
    [fm release];	
    
#else
    
    std::wstring path = std::wstring((wchar_t *)Param.getUTF16StringPtr());
    
	if(path.length()){
		if(path.substr(path.length() - 1) == L"\\"){
			path = path.substr(0, path.length() - 1);
		}		
	}
    
	relative_path_t folder_name;
    get_subpaths(path, absolute_paths, relative_paths, folder_name, ignore_dot, without_enclosing_folder);
    
#endif	
}

unsigned long getFileCrc(absolute_path_t &absolute_path)
{
	unsigned long CRC = crc32(0L, Z_NULL, 0);
	std::ifstream ifs_crc(absolute_path.c_str(), std::ios::in|std::ios::binary);
	if(ifs_crc.is_open())
	{
			std::vector<uint8_t> buf(BUFFER_SIZE);
			while(ifs_crc.good())
			{
					PA_YieldAbsolute();
					ifs_crc.read((char *)&buf[0], BUFFER_SIZE);
					CRC = crc32(CRC, (const Bytef *)&buf[0], ifs_crc.gcount());
			}
			ifs_crc.close();
	}
	return CRC;
}

void Zip(sLONG_PTR *pResult, PackagePtr pParams)
{

    C_TEXT Param1;
    C_TEXT Param2;
    C_TEXT Param3;
    C_LONGINT Param4;
    C_LONGINT Param5;
    C_TEXT Param6;
    C_LONGINT returnValue;
    
    Param1.fromParamAtIndex(pParams, 1);//src
    Param2.fromParamAtIndex(pParams, 2);//dst
    Param3.fromParamAtIndex(pParams, 3);//pass
    Param4.fromParamAtIndex(pParams, 4);//level
    Param5.fromParamAtIndex(pParams, 5);//options
    Param6.fromParamAtIndex(pParams, 6);//callback
    
    //src
    absolute_paths_t absolute_paths;
    relative_paths_t relative_paths;
    relative_path_t input_file_name;
    
    //pass
    CUTF8String password;
    Param3.copyUTF8String(&password);
    
    //dst
#if VERSIONMAC    
    CUTF8String output_path;
    Param2.copyPath(&output_path);
    const char *output = (const char*)output_path.c_str();
#else
    const wchar_t *output = (const wchar_t*)Param2.getUTF16StringPtr();
#endif  
    
    //level
    unsigned int level = Param4.getIntValue();
    if(!level){
        level = Z_DEFAULT_COMPRESSION; 
    }else if (level > 10){
        level = 9;
    }
    
    unsigned int flags = Param5.getIntValue();
    
    bool ignore_dot = !!(flags & 1L);
    
#if VERSIONMAC    
    bool with_atttributes = !!(flags & 2L);
#else
    bool with_atttributes = false;    
#endif

    bool without_enclosing_folder = !!(flags & 4L);
    bool with_encyption = !!(flags & 8L);
	
    //callback
    method_id_t methodId = PA_GetMethodID((PA_Unichar *)Param6.getUTF16StringPtr());
    bool abortedByCallbackMethod = false;
    
	get_subpaths(Param1, &relative_paths, &absolute_paths, ignore_dot, with_atttributes, without_enclosing_folder);

    if(relative_paths.size()){
        
        unsigned long CRC; 
        
        zipFile hZip = zipOpen64(output, APPEND_STATUS_CREATE);
        
        if(hZip){
            
            returnValue.setIntValue(1);
            
            zip_fileinfo zi;
            
            time_t currentTime;
            time(&currentTime);
            
            struct tm *tm;
            tm=localtime(&currentTime);
            
            zi.tmz_date.tm_sec=tm->tm_sec;
            zi.tmz_date.tm_min=tm->tm_min;
            zi.tmz_date.tm_hour=tm->tm_hour;
            zi.tmz_date.tm_mday=tm->tm_mday;
            zi.tmz_date.tm_mon=tm->tm_mon;
            zi.tmz_date.tm_year=tm->tm_year;            
            zi.external_fa = 0;
            zi.internal_fa = 0;
            zi.dosDate = 0;
               
            double number_entry;
               
            bool isCallbackActive = false;
        
            if(methodId){
                    number_entry = relative_paths.size();
                    isCallbackActive = true; 
            }            
                                          
#if VERSIONMAC
            NSFileManager *fm = [[NSFileManager alloc]init];
#endif                       

						std::vector<uint8_t> buf(BUFFER_SIZE);
					
            for (unsigned int i = 0; i < relative_paths.size(); ++i) {
                
                PA_YieldAbsolute();
                
                relative_path_t relative_path = relative_paths.at(i);
                absolute_path_t absolute_path = absolute_paths.at(i); 
                
                zi.external_fa = 0;
#if VERSIONMAC  

                    if(with_atttributes){
                    
                        NSDictionary *attributes = [fm attributesOfItemAtPath:[NSString stringWithUTF8String:(const char *)absolute_path.c_str()]error:nil];
                        
                        if(attributes){
                             
                            if([[attributes valueForKey:NSFileType]isEqualToString:NSFileTypeCharacterSpecial]){
                                zi.external_fa = 0x20000000;
                            }else
                            if([[attributes valueForKey:NSFileType]isEqualToString:NSFileTypeDirectory]){
                                zi.external_fa = 0x40000000;
                            }else
                            if([[attributes valueForKey:NSFileType]isEqualToString:NSFileTypeBlockSpecial]){
                                zi.external_fa = 0x60000000;
                            }else
                            if([[attributes valueForKey:NSFileType]isEqualToString:NSFileTypeRegular]){
                                zi.external_fa = 0x80000000;
                            }else
                            if(([[attributes valueForKey:NSFileType]isEqualToString:NSFileTypeSymbolicLink])){
                                zi.external_fa = 0xA0000000;
                            }else
                            if([[attributes valueForKey:NSFileType]isEqualToString:NSFileTypeSocket]){
                                zi.external_fa = 0xC0000000;
                            }

                            zi.external_fa |= ([[attributes valueForKey:NSFilePosixPermissions]shortValue] << 16L);
                                        
                        }//attributes 
                        
                    }//with_atttributes
#endif                
                
                //callback
                if(isCallbackActive){
                
                    PA_Variable	params[4];
                    params[0] = PA_CreateVariable(eVK_Unistring);
                    params[1] = PA_CreateVariable(eVK_Unistring);
                    params[2] = PA_CreateVariable(eVK_Real);
                    params[3] = PA_CreateVariable(eVK_Real);
                    C_TEXT tempUstr;
                    tempUstr.setUTF8String((const uint8_t *)relative_path.c_str(), relative_path.length());
                    PA_Unistring methodParam1 = PA_CreateUnistring((PA_Unichar *)tempUstr.getUTF16StringPtr());
                    PA_SetStringVariable(&params[0], &methodParam1);
                    tempUstr.setUTF8String((const uint8_t *)absolute_path.c_str(), absolute_path.length());
                    PA_Unistring methodParam2 = PA_CreateUnistring((PA_Unichar *)tempUstr.getUTF16StringPtr());
                    PA_SetStringVariable(&params[1], &methodParam2);
                    
                    PA_SetRealVariable(&params[2], i+1);
                    PA_SetRealVariable(&params[3], number_entry);
                    
                    PA_Variable result = PA_ExecuteMethodByID(methodId, params, 4);
                    PA_DisposeUnistring(&methodParam1);
                    PA_DisposeUnistring(&methodParam2);
                    
                    if(PA_GetVariableKind(result) == eVK_Boolean){
                        
                        abortedByCallbackMethod = PA_GetBooleanVariable(result);
               
                    }
            
                }
                
                if(abortedByCallbackMethod){
                    i = number_entry;
                }

								if (with_encyption)
								{
									CRC = getFileCrc(absolute_path);
									if(zipOpenNewFileInZip3_64(hZip,
																						 relative_path.c_str(),
																						 &zi,
																						 NULL, 0,
																						 NULL, 0,
																						 NULL,
																						 Z_DEFLATED,
																						 level,
																						 0, -MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY,
																						 (password.length() ? (const char *)password.c_str() : NULL), CRC, 1) != 0){
											returnValue.setIntValue(0);
											break;
									}
								}else{
									if(password.length())
									{
										CRC = getFileCrc(absolute_path);

										if(zipOpenNewFileInZip3_64_noAES(hZip,
																							 relative_path.c_str(),
																							 &zi,
																							 NULL, 0,
																							 NULL, 0,
																							 NULL,
																							 Z_DEFLATED,
																							 level,
																							 0, -MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY,
																							 (password.length() ? (const char *)password.c_str() : NULL), CRC, 1) != 0){
												returnValue.setIntValue(0);
												break;
										}
									}else{
                    if(zipOpenNewFileInZip64_noAES(hZip,
                                             relative_path.c_str(),
                                             &zi,
                                             NULL, 0,
                                             NULL, 0,
                                             NULL,
                                             Z_DEFLATED,
                                             level,
                                             0) != 0){
                        returnValue.setIntValue(0);
                        break;
                    }
									}
								}

                bool isSymbolicLink = false;
                
#if VERSIONMAC
                if(with_atttributes){
                    NSString *symbolicPath = (NSString *)CFStringCreateWithFileSystemRepresentation(kCFAllocatorDefault, absolute_path.c_str());
                    NSString *destinationPath = [fm destinationOfSymbolicLinkAtPath:symbolicPath error:nil];
                    if(destinationPath){
                        std::string destinationPath_utf8([destinationPath UTF8String]);
												if (with_encyption){
													zipWriteInFileInZip(hZip, (char *)destinationPath_utf8.c_str(), destinationPath_utf8.size());
												}else{
													zipWriteInFileInZip_noAES(hZip, (char *)destinationPath_utf8.c_str(), destinationPath_utf8.size());
												}
                        [symbolicPath release];
                        isSymbolicLink = TRUE;
                    }  
                }
#endif                

                if(!isSymbolicLink){
                
                    std::ifstream ifs(absolute_path.c_str(), std::ios::in|std::ios::binary);
                
                    if(ifs.is_open()){
											
                        while(ifs.good()){
                            PA_YieldAbsolute();
                            ifs.read((char *)&buf[0], BUFFER_SIZE);
														if (with_encyption){
															zipWriteInFileInZip(hZip, (char *)&buf[0], ifs.gcount());
														}else{
															zipWriteInFileInZip_noAES(hZip, (char *)&buf[0], ifs.gcount());
														}
                        }
                        
                        ifs.close();
                        
                    }
                
                }
								if (with_encyption)
								{
									zipCloseFileInZip(hZip);
								}else{
									zipCloseFileInZip_noAES(hZip);
								}
            }
#if VERSIONMAC
            [fm release];
#endif             
            zipClose(hZip, NULL);
            
        }        
        
    }
        
    if(abortedByCallbackMethod){
        returnValue.setIntValue(0);
    }      
        
    returnValue.setReturn(pResult);
}

void get_relative_path(void *p, absolute_path_t& sub_path, relative_path_t &relative_path){
#if VERSIONWIN
    relative_path = relative_path_t((const char *)p);
    std::string path = relative_path; 
    unescape_path(path);
    utf8_to_wcs(path, sub_path);
#else
    relative_path = absolute_path_t((const char *)p);
    sub_path = relative_path;
#endif    
}

bool create_folder(absolute_path_t& absolute_path){
    
    bool success = false;
    
#if VERSIONMAC
    NSString *path = (NSString *)CFStringCreateWithFileSystemRepresentation(kCFAllocatorDefault, absolute_path.c_str());
    NSFileManager *fm = [[NSFileManager alloc]init];
    success = [fm createDirectoryAtPath:path 
            withIntermediateDirectories:YES
                             attributes:nil
                                  error:NULL];	
    [path release];					
    [fm release];			
#else
    success = SHCreateDirectory(NULL, (PCWSTR)absolute_path.c_str());				
#endif	
    
    return success;
}

void create_parent_folder(absolute_path_t& absolute_path){
#if VERSIONMAC
    NSString *filePath = (NSString *)CFStringCreateWithFileSystemRepresentation(kCFAllocatorDefault, absolute_path.c_str());
    absolute_path_t folderPath = absolute_path_t([[filePath stringByDeletingLastPathComponent]fileSystemRepresentation]);
    create_folder(folderPath);
    [filePath release];
#else	
    wchar_t	fDrive[_MAX_DRIVE],
    fDir[_MAX_DIR],
    fName[_MAX_FNAME],
    fExt[_MAX_EXT];
    _wsplitpath_s(absolute_path.c_str(), fDrive, fDir, fName, fExt);	
    absolute_path_t folderPath = fDrive;
    folderPath += fDir;
    create_folder(folderPath);
#endif	
}

void copy_path(C_TEXT& t, absolute_path_t& p){
#if VERSIONMAC	
    NSString *str = t.copyUTF16String();
    NSURL *u = (NSURL *)CFURLCreateWithFileSystemPath(kCFAllocatorDefault, (CFStringRef)str, kCFURLHFSPathStyle, false);
    
    if(u){
        NSString *path = (NSString *)CFURLCopyFileSystemPath((CFURLRef)u, kCFURLPOSIXPathStyle);
        CFIndex size = CFStringGetMaximumSizeOfFileSystemRepresentation((CFStringRef)path);
        std::vector<uint8_t> buf(size);		
        [path getFileSystemRepresentation:(char *)&buf[0] maxLength:size];
        p = std::string((char *)&buf[0]);
        [path release];
        [u release];
    }	
    
    [str release];
    
#else
    p = std::wstring((wchar_t *)t.getUTF16StringPtr());
    
    if(p.at(p.size() - 1) == L'\\')
        p = p.substr(0, p.size() - 1);
#endif	
}